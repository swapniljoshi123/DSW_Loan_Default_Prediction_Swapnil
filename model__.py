# -*- coding: utf-8 -*-
"""model_.

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pUMpDZE1ZN1QRSW_z86djGtAEuhGbYQm
"""

import pandas as pd
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.preprocessing import StandardScaler
from xgboost import XGBClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score, roc_auc_score, f1_score, classification_report, confusion_matrix

class Model:
    def __init__(self, model_name):
        self.model_name = model_name
        self.model = None
        self.scaler = StandardScaler()
        self.X_train = None
        self.X_test = None
        self.y_train = None
        self.y_test = None

    def load(self, train_data_path, test_data_path):
        train_data = pd.read_excel(train_data_path)
        test_data = pd.read_excel(test_data_path)

        for data in [train_data, test_data]:
            data['transaction_year'] = data['transaction_date'].dt.year
            data['transaction_month'] = data['transaction_date'].dt.month

        categorical_cols = ['sub_grade', 'term', 'home_ownership', 'purpose',
                            'application_type', 'verification_status']

        train_data_encoded = pd.get_dummies(train_data, columns=categorical_cols, drop_first=True)
        test_data_encoded = pd.get_dummies(test_data, columns=categorical_cols, drop_first=True)

        missing_cols = set(train_data_encoded.columns) - set(test_data_encoded.columns)
        for col in missing_cols:
            test_data_encoded[col] = 0
        missing_cols = set(test_data_encoded.columns) - set(train_data_encoded.columns)
        for col in missing_cols:
            train_data_encoded[col] = 0

        train_data_encoded = train_data_encoded.reindex(sorted(train_data_encoded.columns), axis=1)
        test_data_encoded = test_data_encoded.reindex(sorted(test_data_encoded.columns), axis=1)

        feature_cols = [col for col in train_data_encoded.columns if col not in ['loan_status', 'customer_id', 'transaction_date']]
        self.X_train = train_data_encoded[feature_cols]
        self.y_train = train_data_encoded['loan_status']
        self.X_test = test_data_encoded[feature_cols]
        self.y_test = test_data_encoded['loan_status']

    def preprocess(self):
        self.X_train = self.scaler.fit_transform(self.X_train)
        self.X_test = self.scaler.transform(self.X_test)

    def train(self):
        pass

    def test(self):
        pass

    def predict(self):
        pass

class XGBoostModel(Model):
    def __init__(self):
        super().__init__('XGBoost')
        self.model = XGBClassifier(random_state=42, use_label_encoder=False, eval_metric='logloss')

    def train(self):
        param_grid = {
            'n_estimators': [100, 200, 300],
            'learning_rate': [0.01, 0.1, 0.2],
            'max_depth': [3, 6, 9],
            'subsample': [0.8, 1.0],
            'colsample_bytree': [0.8, 1.0]
        }

        grid_search = GridSearchCV(
            estimator=self.model,
            param_grid=param_grid,
            scoring='f1',
            cv=3,
            verbose=2
        )
        grid_search.fit(self.X_train, self.y_train)
        self.model = grid_search.best_estimator_

    def test(self):
        predictions = self.model.predict(self.X_test)
        probabilities = self.model.predict_proba(self.X_test)[:, 1]

        accuracy = accuracy_score(self.y_test, predictions)
        roc_auc = roc_auc_score(self.y_test, probabilities)
        f1 = f1_score(self.y_test, predictions)

        print("\n--- XGBoost Model Evaluation ---")
        print(f"Accuracy: {accuracy:.4f}")
        print(f"ROC-AUC: {roc_auc:.4f}")
        print(f"F1-Score: {f1:.4f}")
        print("\nClassification Report:")
        print(classification_report(self.y_test, predictions))
        print("\nConfusion Matrix:")
        print(confusion_matrix(self.y_test, predictions))

    def predict(self):
        predictions = self.model.predict(self.X_test)
        return predictions

class LogisticRegressionModel(Model):
    def __init__(self, penalty=None):
        super().__init__('Logistic Regression')
        self.model = LogisticRegression(penalty=penalty, max_iter=500, random_state=42)

    def train(self):
        self.model.fit(self.X_train, self.y_train)

    def test(self):
        predictions = self.model.predict(self.X_test)
        probabilities = self.model.predict_proba(self.X_test)[:, 1]

        accuracy = accuracy_score(self.y_test, predictions)
        roc_auc = roc_auc_score(self.y_test, probabilities)
        f1 = f1_score(self.y_test, predictions)

        print("\n--- Logistic Regression Model Evaluation ---")
        print(f"Accuracy: {accuracy:.4f}")
        print(f"ROC-AUC: {roc_auc:.4f}")
        print(f"F1-Score: {f1:.4f}")
        print("\nClassification Report:")
        print(classification_report(self.y_test, predictions))
        print("\nConfusion Matrix:")
        print(confusion_matrix(self.y_test, predictions))

    def predict(self):
        predictions = self.model.predict(self.X_test)
        return predictions

class RandomForestModel(Model):
    def __init__(self):
        super().__init__('Random Forest')
        self.model = RandomForestClassifier(n_estimators=300, max_depth=15, random_state=42)

    def train(self):
        self.model.fit(self.X_train, self.y_train)

    def test(self):
        predictions = self.model.predict(self.X_test)
        probabilities = self.model.predict_proba(self.X_test)[:, 1]

        accuracy = accuracy_score(self.y_test, predictions)
        roc_auc = roc_auc_score(self.y_test, probabilities)
        f1 = f1_score(self.y_test, predictions)

        print("\n--- Random Forest Model Evaluation ---")
        print(f"Accuracy: {accuracy:.4f}")
        print(f"ROC-AUC: {roc_auc:.4f}")
        print(f"F1-Score: {f1:.4f}")
        print("\nClassification Report:")
        print(classification_report(self.y_test, predictions))
        print("\nConfusion Matrix:")
        print(confusion_matrix(self.y_test, predictions))

    def predict(self):
        predictions = self.model.predict(self.X_test)
        return predictions